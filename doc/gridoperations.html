<HTML>
<HEAD>
   <TITLE> module GridOperations (generated by f90doc) </TITLE>
</HEAD>
<H1> Module GridOperations </H1>
<PRE>module GridOperations

        ! Uses
    use <A HREF="datatypesizes.html">DataTypeSizes</A>, ONLY: short, long, float
    use <A HREF="loglib.html">LogLib</A>, ONLY: Catch
    use <A HREF="errorcodes.html">ErrorCodes</A>, ONLY: memAllocError, unknownOption
    use <A HREF="gridlib.html">GridLib</A>, ONLY: grid_integer, grid_real, NewGrid, ESRI_ASCII, ESRI_BINARY, NET_CDF
    use <A HREF="geolib.html">GeoLib</A>, ONLY: OPERATOR (==)

        ! Interfaces
    public interface <A HREF="gridoperations.html#interface_assignment(=)">ASSIGNMENT(=)</A>
    public interface <A HREF="gridoperations.html#interface_gridconvert">GridConvert</A>
    public interface <A HREF="gridoperations.html#interface_getxy">GetXY</A>
    public interface <A HREF="gridoperations.html#interface_getij">GetIJ</A>
    public interface <A HREF="gridoperations.html#interface_crsisequal">CRSisEqual</A>
    public interface <A HREF="gridoperations.html#interface_gridbyini">GridByIni</A>
    public interface <A HREF="gridoperations.html#interface_isoutofgrid">IsOutOfGrid</A>
    public interface <A HREF="gridoperations.html#interface_extractborder">ExtractBorder</A>
    public interface <A HREF="gridoperations.html#interface_gridresample">GridResample</A>
    public interface <A HREF="gridoperations.html#interface_cellarea">CellArea</A>
    public interface <A HREF="gridoperations.html#interface_getmean">GetMean</A>
    public interface <A HREF="gridoperations.html#interface_getsum">GetSum</A>

        ! Subroutines and functions
    private function <A HREF="gridoperations.html#function_cellareafloat">CellAreaFloat</A> (gridIn, i, j) result (cellarea)
    private function <A HREF="gridoperations.html#function_cellareainteger">CellAreaInteger</A> (gridIn, i, j) result (cellarea)
    private subroutine <A HREF="gridoperations.html#subroutine_gridconvertfloat">GridConvertFloat</A> (GridIn, GridOut, cellsize)
    private subroutine <A HREF="gridoperations.html#subroutine_gridconvertinteger">GridConvertInteger</A> (GridIn, GridOut, cellsize)
    private subroutine <A HREF="gridoperations.html#subroutine_getijfloat">GetIJfloat</A> (X, Y, grid, i, j, check)
    private subroutine <A HREF="gridoperations.html#subroutine_getijinteger">GetIJinteger</A> (X, Y, grid, i, j, check)
    private subroutine <A HREF="gridoperations.html#subroutine_getxyfloat">GetXYfloat</A> (i, j, grid, X, Y, check)
    private subroutine <A HREF="gridoperations.html#subroutine_getxyinteger">GetXYinteger</A> (i, j, grid, X, Y, check)
    private function <A HREF="gridoperations.html#function_crsisequalfloatfloat">CRSisEqualFloatFloat</A> (mask, grid, checkCells) result (isEqual)
    private function <A HREF="gridoperations.html#function_crsisequalintint">CRSisEqualIntInt</A> (mask, grid, checkCells) result (isEqual)
    private function <A HREF="gridoperations.html#function_crsisequalfloatint">CRSisEqualFloatInt</A> (mask, grid, checkCells) result (isEqual)
    private function <A HREF="gridoperations.html#function_crsisequalintfloat">CRSisEqualIntFloat</A> (mask, grid, checkCells) result (isEqual)
    private subroutine <A HREF="gridoperations.html#subroutine_gridbyinifloat">GridByIniFloat</A> (ini, grid, section)
    private subroutine <A HREF="gridoperations.html#subroutine_gridbyiniinteger">GridByIniInteger</A> (ini, grid, section)
    public subroutine <A HREF="gridoperations.html#subroutine_gridbyinifloatsubsection">GridByIniFloatSubSection</A> (ini, grid, section, subsection)
    public subroutine <A HREF="gridoperations.html#subroutine_gridbyiniintegersubsection">GridByIniIntegerSubSection</A> (ini, grid, section, subsection)
    private logical function <A HREF="gridoperations.html#function_isoutofgridfloat">IsOutOfGridFloat</A> (i, j, grid)
    private logical function <A HREF="gridoperations.html#function_isoutofgridinteger">IsOutOfGridInteger</A> (i, j, grid)
    private function <A HREF="gridoperations.html#function_extractborderfloat">ExtractBorderFloat</A> (grid, cardinal) result (border)
    private function <A HREF="gridoperations.html#function_extractborderinteger">ExtractBorderInteger</A> (grid, cardinal) result (border)
    private subroutine <A HREF="gridoperations.html#subroutine_resamplefloatcell">ResampleFloatCell</A> (grid, resampledGrid, newCellsize)
    private subroutine <A HREF="gridoperations.html#subroutine_resampleintegercell">ResampleIntegerCell</A> (grid, resampledGrid, newCellsize)
    private subroutine <A HREF="gridoperations.html#subroutine_resamplefloat">ResampleFloat</A> (grid, resampledGrid)
    private subroutine <A HREF="gridoperations.html#subroutine_resampleinteger">ResampleInteger</A> (grid, resampledGrid)
    private subroutine <A HREF="gridoperations.html#subroutine_assigngridreal">AssignGridReal</A> (mat, mask)
    private subroutine <A HREF="gridoperations.html#subroutine_assigngridinteger">AssignGridInteger</A> (mat, mask)
    private subroutine <A HREF="gridoperations.html#subroutine_assignreal">AssignReal</A> (mat, num)
    private subroutine <A HREF="gridoperations.html#subroutine_assigninteger">AssignInteger</A> (mat, num)
    private function <A HREF="gridoperations.html#function_getmeanofgridfloat">GetMeanOfGridFloat</A> (grid, maskReal, maskInteger) result (mean)
    private function <A HREF="gridoperations.html#function_getmeanofgridinteger">GetMeanOfGridInteger</A> (grid, maskReal, maskInteger) result (mean)
    private function <A HREF="gridoperations.html#function_getsumofgridfloat">GetSumOfGridFloat</A> (grid, maskReal, maskInteger) result (sum)
    private function <A HREF="gridoperations.html#function_getsumofgridinteger">GetSumOfGridInteger</A> (grid, maskReal, maskInteger) result (sum)

end module GridOperations
</PRE>
 This file is part of 
<P>
   MOSAICO -- MOdular library for raSter bAsed hydrologIcal appliCatiOn.
<P>
   Copyright (C) 2011 Giovanni Ravazzani
<P>
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
<P>
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
<P>
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 Module Description: 
   library to operate on grids
<P>
<STRONG>Author:</STRONG> <a href="mailto:giovanni.ravazzani@polimi.it">Giovanni Ravazzani</a>
<P>
<STRONG>Version:</STRONG> 0.7 - 19th October 2011

<HR><H2> Description of Interfaces </H2>
<A NAME="interface_assignment(=)"><H3>ASSIGNMENT(=)</H3></A>
<PRE>public interface ASSIGNMENT(=)
    module procedure <A HREF="#subroutine_assigngridreal">AssignGridReal</A>
    module procedure <A HREF="#subroutine_assigngridinteger">AssignGridInteger</A>
    module procedure <A HREF="#subroutine_assignreal">AssignReal</A>
    module procedure <A HREF="#subroutine_assigninteger">AssignInteger</A>
end interface ASSIGNMENT(=)
</PRE>
<A NAME="interface_gridconvert"><H3>GridConvert</H3></A>
<PRE>public interface GridConvert
    module procedure <A HREF="#subroutine_gridconvertfloat">GridConvertFloat</A>
    module procedure <A HREF="#subroutine_gridconvertinteger">GridConvertInteger</A>
end interface GridConvert
</PRE>
<A NAME="interface_getxy"><H3>GetXY</H3></A>
<PRE>public interface GetXY
    module procedure <A HREF="#subroutine_getxyfloat">GetXYFloat</A>
    module procedure <A HREF="#subroutine_getxyinteger">GetXYInteger</A>
end interface GetXY
</PRE>
<A NAME="interface_getij"><H3>GetIJ</H3></A>
<PRE>public interface GetIJ
    module procedure <A HREF="#subroutine_getijfloat">GetIJFloat</A>
    module procedure <A HREF="#subroutine_getijinteger">GetIJInteger</A>
end interface GetIJ
</PRE>
<A NAME="interface_crsisequal"><H3>CRSisEqual</H3></A>
<PRE>public interface CRSisEqual
    module procedure <A HREF="#function_crsisequalintint">CRSisEqualIntInt</A>
    module procedure <A HREF="#function_crsisequalfloatfloat">CRSisEqualFloatFloat</A>
    module procedure <A HREF="#function_crsisequalfloatint">CRSisEqualFloatInt</A>
    module procedure <A HREF="#function_crsisequalintfloat">CRSisEqualIntFloat</A>
end interface CRSisEqual
</PRE>
<A NAME="interface_gridbyini"><H3>GridByIni</H3></A>
<PRE>public interface GridByIni
    module procedure <A HREF="#subroutine_gridbyinifloat">GridByIniFloat</A>
    module procedure <A HREF="#subroutine_gridbyiniinteger">GridByIniInteger</A>
    module procedure <A HREF="#subroutine_gridbyinifloatsubsection">GridByIniFloatSubSection</A>
    module procedure <A HREF="#subroutine_gridbyiniintegersubsection">GridByIniIntegerSubSection</A>
end interface GridByIni
</PRE>
<A NAME="interface_isoutofgrid"><H3>IsOutOfGrid</H3></A>
<PRE>public interface IsOutOfGrid
    module procedure <A HREF="#function_isoutofgridfloat">IsOutOfGridFloat</A>
    module procedure <A HREF="#function_isoutofgridinteger">IsOutOfGridInteger</A>
end interface IsOutOfGrid
</PRE>
<A NAME="interface_extractborder"><H3>ExtractBorder</H3></A>
<PRE>public interface ExtractBorder
    module procedure <A HREF="#function_extractborderfloat">ExtractBorderFloat</A>
    module procedure <A HREF="#function_extractborderinteger">ExtractBorderInteger</A>
end interface ExtractBorder
</PRE>
<A NAME="interface_gridresample"><H3>GridResample</H3></A>
<PRE>public interface GridResample
    module procedure <A HREF="#subroutine_resamplefloatcell">ResampleFloatCell</A>
    module procedure <A HREF="#subroutine_resampleintegercell">ResampleIntegerCell</A>
    module procedure <A HREF="#subroutine_resamplefloat">ResampleFloat</A>
    module procedure <A HREF="#subroutine_resampleinteger">ResampleInteger</A>
end interface GridResample
</PRE>
<A NAME="interface_cellarea"><H3>CellArea</H3></A>
<PRE>public interface CellArea
    module procedure <A HREF="#function_cellareafloat">CellAreaFloat</A>
    module procedure <A HREF="#function_cellareainteger">CellAreaInteger</A>
end interface CellArea
</PRE>
<A NAME="interface_getmean"><H3>GetMean</H3></A>
<PRE>public interface GetMean
    module procedure <A HREF="#function_getmeanofgridfloat">GetMeanOfGridFloat</A>
    module procedure <A HREF="#function_getmeanofgridinteger">GetMeanOfGridInteger</A>
end interface GetMean
</PRE>
<A NAME="interface_getsum"><H3>GetSum</H3></A>
<PRE>public interface GetSum
    module procedure <A HREF="#function_getsumofgridfloat">GetSumOfGridFloat</A>
    module procedure <A HREF="#function_getsumofgridinteger">GetSumOfGridInteger</A>
end interface GetSum
</PRE>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="function_cellareafloat"><H3>CellAreaFloat</H3></A>
<PRE>private function CellAreaFloat (gridIn, i, j) result (cellarea)
    type (grid_real), INTENT (IN) :: gridIn
    integer, INTENT (IN) :: i
</PRE>
<DL><DD><DL><DD>
row and column of cell 
</DL></DL>
<PRE>    integer, INTENT (IN) :: j
</PRE>
<DL><DD><DL><DD>
row and column of cell 
</DL></DL>
<PRE>    real (kind=float) :: cellarea
    ! Calls: Catch, GetXY
end function CellAreaFloat
</PRE>
 Description
   compute area [m2] of a cell of a grid as a function of latitude defined by
   the position of cell in local coordinate system (row, column).
    Input grid of type grid_real
   Reference: Sivakholundu, K. M., Prabaharan, N. (1998). A program to
              compute the area of an irregular polygon on a spheroidal surface,
              Computers & Geosciences, 24(8), 823-826.
<A NAME="function_cellareainteger"><H3>CellAreaInteger</H3></A>
<PRE>private function CellAreaInteger (gridIn, i, j) result (cellarea)
    type (grid_integer), INTENT (IN) :: gridIn
    integer, INTENT (IN) :: i
</PRE>
<DL><DD><DL><DD>
row and column of cell 
</DL></DL>
<PRE>    integer, INTENT (IN) :: j
</PRE>
<DL><DD><DL><DD>
row and column of cell 
</DL></DL>
<PRE>    real (kind=float) :: cellarea
    ! Calls: Catch, GetXY
end function CellAreaInteger
</PRE>
 Description
   compute area [m2] of a cell of a grid as a function of latitude defined by
   the position of cell in local coordinate system (row, column).
    Input grid of type grid_integer
   Reference: Sivakholundu, K. M., Prabaharan, N. (1998). A program to
              compute the area of an irregular polygon on a spheroidal surface,
              Computers & Geosciences, 24(8), 823-826.
<A NAME="subroutine_gridconvertfloat"><H3>GridConvertFloat</H3></A>
<PRE>private subroutine GridConvertFloat (GridIn, GridOut, cellsize)
    type (grid_real), INTENT (IN) :: GridIn
    type (grid_real), INTENT (INOUT) :: GridOut
    real (kind=float), optional, INTENT (IN) :: cellsize
    ! Calls: Catch, Convert, GetIJ, GetXY, SetCoord
end subroutine GridConvertFloat
</PRE>
 Description:
  coordinate conversion of a grid_real
  definition of corner points:
<P>
    A---------B
    |         |
    |         |
    |         |
    C---------D
<A NAME="subroutine_gridconvertinteger"><H3>GridConvertInteger</H3></A>
<PRE>private subroutine GridConvertInteger (GridIn, GridOut, cellsize)
    type (grid_integer), INTENT (IN) :: GridIn
    type (grid_integer), INTENT (INOUT) :: GridOut
    real (kind=float), optional, INTENT (IN) :: cellsize
    ! Calls: Catch, Convert, GetIJ, GetXY, SetCoord
end subroutine GridConvertInteger
</PRE>
 Description:
  coordinate conversion of a grid_integer
  definition of corner points:
<P>
    A---------B
    |         |
    |         |
    |         |
    C---------D
<A NAME="subroutine_getijfloat"><H3>GetIJfloat</H3></A>
<PRE>private subroutine GetIJfloat (X, Y, grid, i, j, check)
    real (kind=float), INTENT(IN) :: X
    real (kind=float), INTENT(IN) :: Y
    type (grid_real), INTENT(IN) :: grid
    integer, INTENT(OUT) :: i
    integer, INTENT(OUT) :: j
    logical, optional, INTENT(OUT) :: check
</PRE>
<DL><DD><DL><DD>
return false if i and j are outside grid definition
</DL></DL>
<PRE>end subroutine GetIJfloat
</PRE>
 Description:
  returns X and Y coordinate given i and j position in grid(i,j)
<A NAME="subroutine_getijinteger"><H3>GetIJinteger</H3></A>
<PRE>private subroutine GetIJinteger (X, Y, grid, i, j, check)
    real (kind=float), INTENT(IN) :: X
    real (kind=float), INTENT(IN) :: Y
    type (grid_integer), INTENT(IN) :: grid
    integer, INTENT(OUT) :: i
    integer, INTENT(OUT) :: j
    logical, optional, INTENT(OUT) :: check
</PRE>
<DL><DD><DL><DD>
return false if i and j are outside grid definition
</DL></DL>
<PRE>end subroutine GetIJinteger
</PRE>
 Description:
  returns X and Y coordinate given i and j position in grid(i,j)
<A NAME="subroutine_getxyfloat"><H3>GetXYfloat</H3></A>
<PRE>private subroutine GetXYfloat (i, j, grid, X, Y, check)
    integer, INTENT(IN) :: i
    integer, INTENT(IN) :: j
    type (grid_real), INTENT(IN) :: grid
    real (kind=float), INTENT(OUT) :: X
    real (kind=float), INTENT(OUT) :: Y
    logical, optional, INTENT(OUT) :: check
</PRE>
<DL><DD><DL><DD>
return false if i and j are outside grid definition
</DL></DL>
<PRE>end subroutine GetXYfloat
</PRE>
 Description:
  returns X and Y coordinate given i and j position in grid(i,j)
<A NAME="subroutine_getxyinteger"><H3>GetXYinteger</H3></A>
<PRE>private subroutine GetXYinteger (i, j, grid, X, Y, check)
    integer, INTENT(IN) :: i
    integer, INTENT(IN) :: j
    type (grid_integer), INTENT(IN) :: grid
    real (kind=float), INTENT(OUT) :: X
    real (kind=float), INTENT(OUT) :: Y
    logical, optional, INTENT(OUT) :: check
</PRE>
<DL><DD><DL><DD>
return false if i and j are outside grid definition
</DL></DL>
<PRE>end subroutine GetXYinteger
</PRE>
 Description:
  returns X and Y coordinate given i and j position in grid(i,j)
<A NAME="function_crsisequalfloatfloat"><H3>CRSisEqualFloatFloat</H3></A>
<PRE>private function CRSisEqualFloatFloat (mask, grid, checkCells) result (isEqual)
    type (grid_real), INTENT(IN) :: mask
    type (grid_real), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: checkCells
    logical :: isEqual
end function CRSisEqualFloatFloat
</PRE>
 Description:
   return .TRUE. if the two grids have the same Coordinate Reference System,
   and the same spatial reference (cellsize, xllxorner, yllcorner, idim, jdim)
   If checkCells is given the function checks that grid has
   the same active cells of mask.
<A NAME="function_crsisequalintint"><H3>CRSisEqualIntInt</H3></A>
<PRE>private function CRSisEqualIntInt (mask, grid, checkCells) result (isEqual)
    type (grid_integer), INTENT(IN) :: mask
    type (grid_integer), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: checkCells
    logical :: isEqual
end function CRSisEqualIntInt
</PRE>
 Description:
   return .TRUE. if the two grids have the same Coordinate Reference System,
   and the same spatial reference (cellsize, xllxorner, yllcorner, idim, jdim)
   If checkCells is given the function checks that grid has
   the same active cells of mask.
<A NAME="function_crsisequalfloatint"><H3>CRSisEqualFloatInt</H3></A>
<PRE>private function CRSisEqualFloatInt (mask, grid, checkCells) result (isEqual)
    type (grid_real), INTENT(IN) :: mask
    type (grid_integer), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: checkCells
    logical :: isEqual
end function CRSisEqualFloatInt
</PRE>
 Description:
   return .TRUE. if the two grids have the same Coordinate Reference System,
   and the same spatial reference (cellsize, xllxorner, yllcorner, idim, jdim)
   If checkCells is given the function checks that grid has
   the same active cells of mask.
<A NAME="function_crsisequalintfloat"><H3>CRSisEqualIntFloat</H3></A>
<PRE>private function CRSisEqualIntFloat (mask, grid, checkCells) result (isEqual)
    type (grid_integer), INTENT(IN) :: mask
    type (grid_real), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: checkCells
    logical :: isEqual
end function CRSisEqualIntFloat
</PRE>
 Description:
   return .TRUE. if the two grids have the same Coordinate Reference System,
   and the same spatial reference (cellsize, xllxorner, yllcorner, idim, jdim)
   If checkCells is given the function checks that grid has
   the same active cells of mask.
<A NAME="subroutine_gridbyinifloat"><H3>GridByIniFloat</H3></A>
<PRE>private subroutine GridByIniFloat (ini, grid, section)
    type (IniList), INTENT(IN) :: ini
    type (grid_real), INTENT (OUT) :: grid
    character (len=*), INTENT (IN) :: section
    ! Calls: Catch, NewGrid, SetCRS, SetGeodeticParameters, SetSwissParameters, SetTransverseMercatorParameters
end subroutine GridByIniFloat
</PRE>
 Description:
   read a grid_real using information stored in ini configuration file
<A NAME="subroutine_gridbyiniinteger"><H3>GridByIniInteger</H3></A>
<PRE>private subroutine GridByIniInteger (ini, grid, section)
    type (IniList), INTENT(IN) :: ini
    type (grid_integer), INTENT (OUT) :: grid
    character (len=*), INTENT (IN) :: section
    ! Calls: Catch, NewGrid, SetCRS, SetGeodeticParameters, SetSwissParameters, SetTransverseMercatorParameters
end subroutine GridByIniInteger
</PRE>
 Description:
   read a grid_integer using information stored in ini configuration file
<A NAME="subroutine_gridbyinifloatsubsection"><H3>GridByIniFloatSubSection</H3></A>
<PRE>public subroutine GridByIniFloatSubSection (ini, grid, section, subsection)
    type (IniList), INTENT(IN) :: ini
    type (grid_real), INTENT (OUT) :: grid
    character (len=*), INTENT (IN) :: section
    character (len=*), INTENT (IN) :: subsection
    ! Calls: Catch, NewGrid, SetCRS, SetGaussBoagaParameters, SetGeodeticParameters, SetUTMparameters
end subroutine GridByIniFloatSubSection
</PRE>
 Description:
   read a grid_real using information stored in ini configuration file
   defined in subsection [[...]]
<A NAME="subroutine_gridbyiniintegersubsection"><H3>GridByIniIntegerSubSection</H3></A>
<PRE>public subroutine GridByIniIntegerSubSection (ini, grid, section, subsection)
    type (IniList), INTENT(IN) :: ini
    type (grid_integer), INTENT (OUT) :: grid
    character (len=*), INTENT (IN) :: section
    character (len=*), INTENT (IN) :: subsection
    ! Calls: Catch, NewGrid, SetCRS, SetGaussBoagaParameters, SetGeodeticParameters, SetUTMparameters
end subroutine GridByIniIntegerSubSection
</PRE>
 Description:
   read a grid_integer using information stored in ini configuration file
   defined in subsection [[.. ]]
<A NAME="function_isoutofgridfloat"><H3>IsOutOfGridFloat</H3></A>
<PRE>private logical function IsOutOfGridFloat (i, j, grid)
    integer, INTENT(IN) :: i
    integer, INTENT(IN) :: j
    type (grid_real), INTENT(IN) :: grid
end function IsOutOfGridFloat
</PRE>
 Description:
   calculates if cell is out of grid space limits
<A NAME="function_isoutofgridinteger"><H3>IsOutOfGridInteger</H3></A>
<PRE>private logical function IsOutOfGridInteger (i, j, grid)
    integer, INTENT(IN) :: i
    integer, INTENT(IN) :: j
    type (grid_integer), INTENT(IN) :: grid
end function IsOutOfGridInteger
</PRE>
 Description:
   calculates if cell is out of grid space limits
<A NAME="function_extractborderfloat"><H3>ExtractBorderFloat</H3></A>
<PRE>private function ExtractBorderFloat (grid, cardinal) result (border)
    type (grid_real), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: cardinal
    type (grid_real) :: border
    ! Calls: NewGrid
end function ExtractBorderFloat
</PRE>
 Description:
   Extracts only the cells on the external border. Other cells are 
   assigned nodata. Border cell is the one that has at least a
   nodata value in the neighbouring 8 cells.
<A NAME="function_extractborderinteger"><H3>ExtractBorderInteger</H3></A>
<PRE>private function ExtractBorderInteger (grid, cardinal) result (border)
    type (grid_integer), INTENT(IN) :: grid
    logical, optional, INTENT(IN) :: cardinal
    type (grid_integer) :: border
    ! Calls: NewGrid
end function ExtractBorderInteger
</PRE>
 Description:
   Extracts only the cells on the external border. Other cells are 
   assigned nodata. Border cell is the one that has at least a
   nodata value in the neighbouring 8 cells. If cardinal is passed
   the routine checks only the four cells in the cardinal direction.
   This option is used to obtain border without duplicates. Default is
   check all the cells.
<A NAME="subroutine_resamplefloatcell"><H3>ResampleFloatCell</H3></A>
<PRE>private subroutine ResampleFloatCell (grid, resampledGrid, newCellsize)
    type (grid_real), INTENT(IN) :: grid
    type (grid_real), INTENT(OUT) :: resampledGrid
    real (kind=float), INTENT(IN) :: newCellsize
    ! Calls: GetIJ, GetXY
end subroutine ResampleFloatCell
</PRE>
 Description:
   Create a new grid_real with cellsize different from input grid
   The content of the created grid is filled in with nearest neighbor method
<A NAME="subroutine_resampleintegercell"><H3>ResampleIntegerCell</H3></A>
<PRE>private subroutine ResampleIntegerCell (grid, resampledGrid, newCellsize)
    type (grid_integer), INTENT(IN) :: grid
    type (grid_integer), INTENT(OUT) :: resampledGrid
    real (kind=float), INTENT(IN) :: newCellsize
    ! Calls: GetIJ, GetXY
end subroutine ResampleIntegerCell
</PRE>
 Description:
   Create a new grid_integer with cellsize different from input grid
   The content of the created grid is filled in with nearest neighbor method
<A NAME="subroutine_resamplefloat"><H3>ResampleFloat</H3></A>
<PRE>private subroutine ResampleFloat (grid, resampledGrid)
    type (grid_real), INTENT(IN) :: grid
    type (grid_real), INTENT(INOUT) :: resampledGrid
    ! Calls: Catch, GetIJ, GetXY
end subroutine ResampleFloat
</PRE>
 Description:
    Fill in a grid with a different cellsize from input grid.
    Both input grid and output grid exist.   
<A NAME="subroutine_resampleinteger"><H3>ResampleInteger</H3></A>
<PRE>private subroutine ResampleInteger (grid, resampledGrid)
    type (grid_integer), INTENT(IN) :: grid
    type (grid_integer), INTENT(INOUT) :: resampledGrid
    ! Calls: Catch, GetIJ, GetXY
end subroutine ResampleInteger
</PRE>
 Description:
    Fill in a grid with a different cellsize from input grid.
    Both input grid and output grid exist.   
<A NAME="subroutine_assigngridreal"><H3>AssignGridReal</H3></A>
<PRE>private subroutine AssignGridReal (mat, mask)
    type (grid_real), INTENT(INOUT) :: mat
    type (grid_real), INTENT(IN) :: mask
    ! Calls: Catch
end subroutine AssignGridReal
</PRE>
 Description:
   assign value of mask to mat
<A NAME="subroutine_assigngridinteger"><H3>AssignGridInteger</H3></A>
<PRE>private subroutine AssignGridInteger (mat, mask)
    type (grid_integer), INTENT(INOUT) :: mat
    type (grid_integer), INTENT(IN) :: mask
    ! Calls: Catch
end subroutine AssignGridInteger
</PRE>
 Description:
   assign value of mask to mat
<A NAME="subroutine_assignreal"><H3>AssignReal</H3></A>
<PRE>private subroutine AssignReal (mat, num)
    type (grid_real), INTENT(INOUT) :: mat
    real (kind=float), INTENT(IN) :: num
end subroutine AssignReal
</PRE>
 Description:
   assign value  to mat
<A NAME="subroutine_assigninteger"><H3>AssignInteger</H3></A>
<PRE>private subroutine AssignInteger (mat, num)
    type (grid_integer), INTENT(INOUT) :: mat
    integer, INTENT(IN) :: num
end subroutine AssignInteger
</PRE>
 Description:
   assign value  to mat
<A NAME="function_getmeanofgridfloat"><H3>GetMeanOfGridFloat</H3></A>
<PRE>private function GetMeanOfGridFloat (grid, maskReal, maskInteger) result (mean)
    type (grid_real), INTENT(IN) :: grid
    type (grid_real), optional, INTENT(IN) :: maskReal
    type (grid_integer), optional, INTENT(IN) :: maskInteger
    real (kind=float) :: mean
    ! Calls: Catch
end function GetMeanOfGridFloat
</PRE>
 Description:
   compute mean of grid_real eventually constrained to a mask
<A NAME="function_getmeanofgridinteger"><H3>GetMeanOfGridInteger</H3></A>
<PRE>private function GetMeanOfGridInteger (grid, maskReal, maskInteger) result (mean)
    type (grid_integer), INTENT(IN) :: grid
    type (grid_real), optional, INTENT(IN) :: maskReal
    type (grid_integer), optional, INTENT(IN) :: maskInteger
    real (kind=float) :: mean
    ! Calls: Catch
end function GetMeanOfGridInteger
</PRE>
 Description:
   compute mean of grid_integer eventually constrained to a mask
<A NAME="function_getsumofgridfloat"><H3>GetSumOfGridFloat</H3></A>
<PRE>private function GetSumOfGridFloat (grid, maskReal, maskInteger) result (sum)
    type (grid_real), INTENT(IN) :: grid
    type (grid_real), optional, INTENT(IN) :: maskReal
    type (grid_integer), optional, INTENT(IN) :: maskInteger
    real (kind=float) :: sum
    ! Calls: Catch
end function GetSumOfGridFloat
</PRE>
 Description:
   compute sum of grid_real eventually constrained to a mask
<A NAME="function_getsumofgridinteger"><H3>GetSumOfGridInteger</H3></A>
<PRE>private function GetSumOfGridInteger (grid, maskReal, maskInteger) result (sum)
    type (grid_integer), INTENT(IN) :: grid
    type (grid_real), optional, INTENT(IN) :: maskReal
    type (grid_integer), optional, INTENT(IN) :: maskInteger
    integer (kind=long) :: sum
    ! Calls: Catch
end function GetSumOfGridInteger
</PRE>
 Description:
   compute sum of grid_integer eventually constrained to a mask
</HTML>
