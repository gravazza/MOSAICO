<HTML>
<HEAD>
   <TITLE> module TableLib (generated by f90doc) </TITLE>
</HEAD>
<H1> Module TableLib </H1>
<PRE>module TableLib

        ! Uses
    use <A HREF="datatypesizes.html">DataTypeSizes</A>, ONLY : short, long, float, double
    use <A HREF="loglib.html">LogLib</A>, ONLY : Catch
    use <A HREF="utilities.html">Utilities</A>, ONLY : LinearInterp

        ! Types
    public type <A HREF="tablelib.html#type_table">Table</A>
    public type <A HREF="tablelib.html#type_tablecollection">TableCollection</A>
    private type <A HREF="tablelib.html#type_column">Column</A>

        ! Variables
    integer (kind=long), private, PARAMETER :: <A HREF="tablelib.html#var_linelength">LINELENGTH</A> = 1000

        ! Interfaces
    public interface <A HREF="tablelib.html#interface_tablenew">TableNew</A>
    public interface <A HREF="tablelib.html#interface_tablegetvalue">TableGetValue</A>
    public interface <A HREF="tablelib.html#interface_tableexport">TableExport</A>
    public interface <A HREF="tablelib.html#interface_tablegetnrows">TableGetNrows</A>

        ! Subroutines and functions
    private subroutine <A HREF="tablelib.html#subroutine_tablewritetofile">TableWriteToFile</A> (tab, file)
    private subroutine <A HREF="tablelib.html#subroutine_tablewritetounit">TableWriteToUnit</A> (tab, iunit)
    private subroutine <A HREF="tablelib.html#subroutine_tableswritetofile">TablesWriteToFile</A> (tables, file, id)
    private subroutine <A HREF="tablelib.html#subroutine_tableswritetounit">TablesWriteToUnit</A> (tables, iunit, id)
    private subroutine <A HREF="tablelib.html#subroutine_tablegetfloat">TableGetFloat</A> (valueIn, tab, keyIn, keyOut, match, valueOut, bound)
    private subroutine <A HREF="tablelib.html#subroutine_tablesgetfloat">TablesGetFloat</A> (valueIn, tables, id, keyIn, keyOut, match, valueOut, bound)
    private subroutine <A HREF="tablelib.html#subroutine_tablegetdouble">TableGetDouble</A> (valueIn, tab, keyIn, keyOut, match, valueOut, bound)
    private subroutine <A HREF="tablelib.html#subroutine_tablesgetdouble">TablesGetDouble</A> (valueIn, tables, id, keyIn, keyOut, match, valueOut, bound)
    private subroutine <A HREF="tablelib.html#subroutine_tablegetstring">TableGetString</A> (valueIn, tab, keyIn, keyOut, valueOut)
    private subroutine <A HREF="tablelib.html#subroutine_tablesgetstring">TablesGetString</A> (valueIn, tables, id, keyIn, keyOut, valueOut)
    private function <A HREF="tablelib.html#function_tablesyncbyid">TableSyncById</A> (tables, id) result (pos)
    private function <A HREF="tablelib.html#function_tablefilesync">TableFileSync</A> (unit, id, line) result (code)
    private function <A HREF="tablelib.html#function_tablereadtitle">TableReadTitle</A> (lines) result (title)
    private function <A HREF="tablelib.html#function_tablereadid">TableReadId</A> (lines) result (id)
    private subroutine <A HREF="tablelib.html#subroutine_tablesgetfromfile">TablesGetFromFile</A> (file, tables)
    private subroutine <A HREF="tablelib.html#subroutine_tablesgetfromunit">TablesGetFromUnit</A> (unit, tables)
    private subroutine <A HREF="tablelib.html#subroutine_tablegetfromfile">TableGetFromFile</A> (file, tab, id)
    private subroutine <A HREF="tablelib.html#subroutine_tablegetfromunit">TableGetFromUnit</A> (unit, tab, id)
    private subroutine <A HREF="tablelib.html#subroutine_tablereadcontent">TableReadContent</A> (lines, tab)
    private subroutine <A HREF="tablelib.html#subroutine_tablereadunit">TableReadUnit</A> (lines, tab)
    private subroutine <A HREF="tablelib.html#subroutine_tablereadheader">TableReadHeader</A> (lines, tab)
    private function <A HREF="tablelib.html#function_tablecountcols">TableCountCols</A> (lines) result (cols)
    private function <A HREF="tablelib.html#function_tablecountrows">TableCountRows</A> (lines) result (rows)
    private subroutine <A HREF="tablelib.html#subroutine_checkid">CheckId</A> (tables, pos)
    private subroutine <A HREF="tablelib.html#subroutine_tablestorelines">TableStoreLines</A> (unit, lines)
    private function <A HREF="tablelib.html#function_tablegetnumberrows">TableGetNumberRows</A> (tab) result (rows)
    public function <A HREF="tablelib.html#function_tablesgetnumberrows">TablesGetNumberRows</A> (tables, id) result (rows)

end module TableLib
</PRE>
 This file is part of 
<P>
 MOSAICO -- MOdular library for raSter bAsed hydrologIcal appliCatiOn.
<P>
   Copyright (C) 2011 Giovanni Ravazzani
<P>
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
<P>
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
<P>
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 Module Description: 
   Module for manage tables
   Tables are stored in plain text. 
   One single file may contain more than one table. 
   Example of a table:
<P>
<PRE>  Table Start
  Title: Stage discharge relatioship. #inline comment
  Id: Tab01 # mandatory
	
  # This is a sample comment.  You can put anything you want
  # on comment lines. Comment lines can be put everywhere

  Columns:    [Stage]        [Discharge]      [Method]
  Units:     [m a.s.l.]         [m3/s]          [-]
              300.0             10.0          measure
              300.5             20.0          measure
              301.0             50.0          measure
              301.5             100.0         extrapolation
              302.0             200.0         extrapolation
              302.5             500.0         extrapolation
  # another comment
  Table End</PRE>
<P>
 Example program:
<PRE> PROGRAM TestTableLib

USE TableLib
USE DataTypeSizes

TYPE (TableCollection) :: tables
TYPE (Table) :: tab, tab2
REAL (KIND = float) :: out
REAL (KIND = double) :: dOut
INTEGER :: i

!initialize a new table reading from the file passed as an argument.
!At the end of initialization, file is closed.
CALL TableNew ( 'table.txt', tab )

!initialize a new table reading from a file already open. 
!Unit of the file is passed as an argument.
!At the end of initialization, file is not closed.
OPEN (unit=10, file='table2.txt')
CALL TableNew ( 10, tab2 ) !mettere controllo che il file sia aperto.

!initialize a collection of tables reading from a file whose name 
!is specified as argument.
CALL TableNew ( 'tables.txt', tables )

!extract value from table with different methods.
!input value must be a float number. Output can be long integer, 
!float real or double real.

!get float that corresponds exactly to input float. Bound is not 
!necessary (it does not make sense).
!If input value is not found, an error message is logged.
CALL TableGetValue ( 302., tab, 'stage', 'discharge', 'exact', out)
WRITE(*,*) 'The discharge corresponding to selected case is: ', out

!get float calculating a linear interpolation between the two nearest values. 
!Option bound = 'fixed' limits the search inside the extreme values 
!of the table. If extreme values are exceeded, an error is thrown.
CALL TableGetValue ( 302.4, tab, 'stage', 'discharge', 'linear', out, &
                     bound = 'fixed' )
WRITE(*,*) 'The discharge corresponding to input value is: ', out

!get float calculating a linear interpolation between the two nearest values. 
!Option bound = 'extendlinear' means that if the input value is outside 
!extreme values of the table, they are linearly extended  using the 
!last two elements of the table. A warning message is logged.
CALL TableGetValue ( 304., tab, 'stage', 'discharge', 'linear', out, &
                     bound = 'extendlinear' )
WRITE(*,*) 'The discharge corresponding to input value is: ', out

!get float calculating a linear interpolation between the two nearest values. 
!Option bound = 'extendconstant' means that if the input value is 
!outside extreme values of the table, the last element is extended 
!as a constant. A warning message is logged.
CALL TableGetValue ( 304., tab, 'stage', 'discharge', 'linear', out, &
                     bound = 'extendconstant' )
WRITE(*,*) 'The discharge corresponding to input value is: ', out

!get float searching for the nearest value.
CALL TableGetValue ( 302.55, tab, 'stage', 'discharge', 'nearest', out)
WRITE(*,*) 'The discharge nearest to input value is: ', out

!get double calculating a linear interpolation between the two nearest values. 
!Option bound = 'fixed' limits the search inside the extreme values of the 
!table. If extreme values are exceeded, an error is thrown.
CALL TableGetValue ( 302.4, tab, 'stage', 'discharge', 'linear', dOut, &
                     bound = 'fixed' )
WRITE(*,*) 'The discharge corresponding to input value is: ', dOut

!get float calculating a linear interpolation between the two nearest values. 
!Option bound = 'fixed' limits the search inside the extreme values of 
!the table. If extreme values are exceeded, an error is thrown.
CALL TableGetValue ( 302.4, tables, 'tab02', 'stage', 'discharge', 'linear', &
                     out, bound = 'fixed' )
WRITE(*,*) 'The discharge corresponding to input value is: ', out

!get double calculating a linear interpolation between the two nearest values.
! Option bound = 'fixed' limits the search inside the extreme values of the table. 
!If extreme values are exceeded, an error is thrown.
CALL TableGetValue ( 302.4, tables, 'tab02', 'stage', 'discharge', 'linear', &
                     dOut, bound = 'fixed' )
WRITE(*,*) 'The discharge corresponding to input value is: ', dOut

!export table on file. Name of the file is passed as argument
CALL TableExport ( tab, 'fileout.txt' )

!export table on a file taht is already open. Unit of file is passed as argument
OPEN (UNIT = 20, file = 'exported_table.txt')
CALL TableExport ( tab, 20 )
CLOSE (20)

!export a collection of tables on a file. Name of the file is passed as argument
CALL TableExport ( tables, 'table_collections.txt' )

!export just one table from a collection of tables on a filetaht is already open. 
!Unit of file is passed as argument
OPEN (UNIT = 20, file = 'tab02.txt')
CALL TableExport ( tables, 20, 'tab02' )
CLOSE (20)

 END PROGRAM TestTableLib</PRE>
<P>
 References and Credits:
   ODT data table format http://math.nist.gov/oommf/doc/userguide11b2/userguide/Data_table_format_ODT.html
<P>
 Known issues:
   when processing table with lots of rows, stack overflow may occur. 
   Decrease LINELENGTH parameter or increase stack size before compiling.
<P>
 TODO
 TableGetString
 TableGetLong
<P>
<STRONG>Author:</STRONG> <a href="mailto:giovanni.ravazzani@polimi.it">Giovanni Ravazzani</a>
<P>
<STRONG>Version:</STRONG> 1.1 - 4th Januray 2011

<HR><H2> Description of Types </H2>
<A NAME="type_table"><H3>Table</H3></A>
<PRE>public type Table
    character (len=300) :: title
</PRE>
<DL><DD><DL><DD>
 Max length of title: 300 characters
</DL></DL>
<PRE>    character (len=30) :: id
</PRE>
<DL><DD><DL><DD>
 Max length of id: 30 characters
</DL></DL>
<PRE>    integer (kind=long) :: noRows
</PRE>
<DL><DD><DL><DD>
 number of rows
</DL></DL>
<PRE>    integer (kind=long) :: noCols
</PRE>
<DL><DD><DL><DD>
 number of columns
</DL></DL>
<PRE>    type (Column), POINTER, dimension  (:) :: col
end type Table
</PRE>
<A NAME="type_tablecollection"><H3>TableCollection</H3></A>
<PRE>public type TableCollection
    integer (kind=long) :: number
    type (Table), POINTER, dimension  (:) :: elem
end type TableCollection
</PRE>
<A NAME="type_column"><H3>Column</H3></A>
<PRE>private type Column
    character (len=100) :: header
    character (len=100) :: unit
    character (len=100), POINTER, dimension  (:) :: row
end type Column
</PRE>

<HR><H2> Description of Variables </H2>
<A NAME="var_linelength"><H3>LINELENGTH</H3></A>
<PRE>integer (kind=long), private, PARAMETER :: LINELENGTH = 1000
</PRE>

<HR><H2> Description of Interfaces </H2>
<A NAME="interface_tablenew"><H3>TableNew</H3></A>
<PRE>public interface TableNew
    module procedure <A HREF="#subroutine_tablesgetfromfile">TablesGetFromFile</A>
    module procedure <A HREF="#subroutine_tablesgetfromunit">TablesGetFromUnit</A>
    module procedure <A HREF="#subroutine_tablegetfromfile">TableGetFromFile</A>
    module procedure <A HREF="#subroutine_tablegetfromunit">TableGetFromUnit</A>
end interface TableNew
</PRE>
<A NAME="interface_tablegetvalue"><H3>TableGetValue</H3></A>
<PRE>public interface TableGetValue
    module procedure <A HREF="#subroutine_tablegetfloat">TableGetFloat</A>
    module procedure <A HREF="#subroutine_tablegetdouble">TableGetDouble</A>
    module procedure <A HREF="#subroutine_tablegetstring">TableGetString</A>
    module procedure <A HREF="#subroutine_tablesgetfloat">TablesGetFloat</A>
    module procedure <A HREF="#subroutine_tablesgetdouble">TablesGetDouble</A>
    module procedure <A HREF="#subroutine_tablesgetstring">TablesGetString</A>
end interface TableGetValue
</PRE>
<A NAME="interface_tableexport"><H3>TableExport</H3></A>
<PRE>public interface TableExport
    module procedure <A HREF="#subroutine_tablewritetofile">TableWriteToFile</A>
    module procedure <A HREF="#subroutine_tablewritetounit">TableWriteToUnit</A>
    module procedure <A HREF="#subroutine_tableswritetofile">TablesWriteToFile</A>
    module procedure <A HREF="#subroutine_tableswritetounit">TablesWriteToUnit</A>
end interface TableExport
</PRE>
<A NAME="interface_tablegetnrows"><H3>TableGetNrows</H3></A>
<PRE>public interface TableGetNrows
    module procedure <A HREF="#function_tablegetnumberrows">TableGetNumberRows</A>
    module procedure <A HREF="#function_tablesgetnumberrows">TablesGetNumberRows</A>
end interface TableGetNrows
</PRE>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_tablewritetofile"><H3>TableWriteToFile</H3></A>
<PRE>private subroutine TableWriteToFile (tab, file)
    type (Table), INTENT (IN) :: tab
    character (len=*), INTENT (IN) :: file
end subroutine TableWriteToFile
</PRE>
 Description:
 write a table on file. 
<PRE> Arguments:
   tab      table to export
   file     file to whom write the table</PRE>
<A NAME="subroutine_tablewritetounit"><H3>TableWriteToUnit</H3></A>
<PRE>private subroutine TableWriteToUnit (tab, iunit)
    type (Table), INTENT (IN) :: tab
    integer (kind=short), INTENT (IN) :: iunit
end subroutine TableWriteToUnit
</PRE>
 Description:
 write a table on file taht is already open. 
<PRE> Arguments:
   tab      table to export
   iunit    unit of file to whom write the table</PRE>
<A NAME="subroutine_tableswritetofile"><H3>TablesWriteToFile</H3></A>
<PRE>private subroutine TablesWriteToFile (tables, file, id)
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: file
    character (len=*), optional, INTENT (IN) :: id
    ! Calls: TableWriteToUnit
end subroutine TablesWriteToFile
</PRE>
 Description:
 write a collection of tables on file. If id is present, only the table 
 corresponding to that id is written.
<PRE> Arguments:
   tables   collection of tables to be exported
   file     file to whom write the table</PRE>
<A NAME="subroutine_tableswritetounit"><H3>TablesWriteToUnit</H3></A>
<PRE>private subroutine TablesWriteToUnit (tables, iunit, id)
    type (TableCollection), INTENT (IN) :: tables
    integer (kind=short), INTENT (IN) :: iunit
    character (len=*), optional, INTENT (IN) :: id
    ! Calls: TableWriteToUnit
end subroutine TablesWriteToUnit
</PRE>
 Description:
 write a collection of tables on file already open. If id is present, 
 only the table corresponding to that id is written.
<PRE> Arguments:
   tables   collection of tables to be exported
   iunit    unit to whom write the table</PRE>
<A NAME="subroutine_tablegetfloat"><H3>TableGetFloat</H3></A>
<PRE>private subroutine TableGetFloat (valueIn, tab, keyIn, keyOut, match, valueOut, bound)
    real (kind=float), INTENT (IN) :: valueIn
    type (Table), INTENT (IN) :: tab
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (IN) :: match
    real (kind=float), INTENT (OUT) :: valueOut
    character (len=*), optional, INTENT (IN) :: bound
    ! Calls: Catch
end subroutine TableGetFloat
</PRE>
 Description:
 returns a float from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. 
<PRE> Arguments:
   valueIn  input value
   tab      table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value
   match    method to match input value. Possible values are:
            'exact'  = column must contain exact input value
            'linear' = calculates linear interpolation between two 
                       bounding values
            'nearest'  = search for the nearest value in input column
   bound    method to manage bounds. Possible values are:
            'fixed'  = extreme values are treated as a wall
            'extendlinear' = extend bounds with linear interpolation 
                             of last two extreme values 
            'extendconstant'  = extend bounds preserving extreme value constant</PRE>
<A NAME="subroutine_tablesgetfloat"><H3>TablesGetFloat</H3></A>
<PRE>private subroutine TablesGetFloat (valueIn, tables, id, keyIn, keyOut, match, valueOut, bound)
    real (kind=float), INTENT (IN) :: valueIn
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: id
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (IN) :: match
    real (kind=float), INTENT (OUT) :: valueOut
    character (len=*), optional, INTENT (IN) :: bound
    ! Calls: TableGetFloat
end subroutine TablesGetFloat
</PRE>
 Description:
 returns a float from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. Table is identified by its id.
<PRE> Arguments:
   valueIn  input value
   tables   collection of tables to search in
   id       id of the table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value
   match    method to match input value. Possible values are:
            'exact'  = column must contain exact input value
            'linear' = calculates linear interpolation between two 
                       bounding values
            'nearest'  = search for the nearest value in input column
   bound    method to manage bounds. Possible values are:
            'fixed'  = extreme values are treated as a wall
            'extendlinear' = extend bounds with linear interpolation 
                             of last two extreme values 
            'extendconstant'  = extend bounds preserving extreme value constant</PRE>
<A NAME="subroutine_tablegetdouble"><H3>TableGetDouble</H3></A>
<PRE>private subroutine TableGetDouble (valueIn, tab, keyIn, keyOut, match, valueOut, bound)
    real (kind=float), INTENT (IN) :: valueIn
    type (Table), INTENT (IN) :: tab
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (IN) :: match
    real (kind=double), INTENT (OUT) :: valueOut
    character (len=*), optional, INTENT (IN) :: bound
    ! Calls: Catch
end subroutine TableGetDouble
</PRE>
 Description:
 returns a double from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. 
<PRE> Arguments:
   valueIn  input value
   tab      table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value
   match    method to match input value. Possible values are:
            'exact'  = column must contain exact input value
            'linear' = calculates linear interpolation between two 
                       bounding values
            'nearest'  = search for the nearest value in input column
   bound    method to manage bounds. Possible values are:
            'fixed'  = extreme values are treated as a wall
            'extendlinear' = extend bounds with linear interpolation 
                             of last two extreme values 
            'extendconstant'  = extend bounds preserving extreme value constant</PRE>
<A NAME="subroutine_tablesgetdouble"><H3>TablesGetDouble</H3></A>
<PRE>private subroutine TablesGetDouble (valueIn, tables, id, keyIn, keyOut, match, valueOut, bound)
    real (kind=float), INTENT (IN) :: valueIn
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: id
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (IN) :: match
    real (kind=double), INTENT (OUT) :: valueOut
    character (len=*), optional, INTENT (IN) :: bound
    ! Calls: TableGetDouble
end subroutine TablesGetDouble
</PRE>
 Description:
 returns a double from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. Table is identified by its id.
<PRE> Arguments:
   valueIn  input value
   tables   collection of tables to search in
   id       id of the table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value
   match    method to match input value. Possible values are:
            'exact'  = column must contain exact input value
            'linear' = calculates linear interpolation between two 
                       bounding values
            'nearest'  = search for the nearest value in input column
   bound    method to manage bounds. Possible values are:
            'fixed'  = extreme values are treated as a wall
            'extendlinear' = extend bounds with linear interpolation 
                             of last two extreme values 
            'extendconstant'  = extend bounds preserving extreme value constant</PRE>
<A NAME="subroutine_tablegetstring"><H3>TableGetString</H3></A>
<PRE>private subroutine TableGetString (valueIn, tab, keyIn, keyOut, valueOut)
    real (kind=float), INTENT (IN) :: valueIn
    type (Table), INTENT (IN) :: tab
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (OUT) :: valueOut
    ! Calls: Catch
end subroutine TableGetString
</PRE>
 Description:
 returns a string from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. 
<PRE> Arguments:
   valueIn  input value
   tab      table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value</PRE>
<A NAME="subroutine_tablesgetstring"><H3>TablesGetString</H3></A>
<PRE>private subroutine TablesGetString (valueIn, tables, id, keyIn, keyOut, valueOut)
    real (kind=float), INTENT (IN) :: valueIn
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: id
    character (len=*), INTENT (IN) :: keyIn
    character (len=*), INTENT (IN) :: keyOut
    character (len=*), INTENT (OUT) :: valueOut
    ! Calls: TableGetString
end subroutine TablesGetString
</PRE>
 Description:
 returns a string from column defined by keyOut corresponding to valueIn 
 contained in column defined by keyIn. Table is identified by its id.
<PRE> Arguments:
   valueIn  input value
   tables   collection of tables to search in
   id       id of the table to search in
   keyIn    defines header of the column of the input value
   keyOut   defines header of the column of the output value</PRE>
<A NAME="function_tablesyncbyid"><H3>TableSyncById</H3></A>
<PRE>private function TableSyncById (tables, id) result (pos)
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: id
    integer (kind=long) :: pos
    ! Calls: Catch
end function TableSyncById
</PRE>
 Description:
 returns the position of table in collection of tables identified by id. 
<PRE> Arguments:
   tables   collection of tables to search in
   id       id of the table</PRE>
<A NAME="function_tablefilesync"><H3>TableFileSync</H3></A>
<PRE>private function TableFileSync (unit, id, line) result (code)
    integer (kind=short), INTENT (IN) :: unit
    character (len=*), optional, INTENT(IN) :: id
    integer (kind=long), optional, INTENT (INOUT) :: line
    integer (kind=short) :: code
end function TableFileSync
</PRE>
 Description:
 search the file for beginning of next table defined by keyword Table Start 
<PRE> Arguments:
     unit     file in which operate search
     line     optional, line of file to begin search
 Result:
     Return -1 when table is not found
     line of beginning of a table</PRE>
<A NAME="function_tablereadtitle"><H3>TableReadTitle</H3></A>
<PRE>private function TableReadTitle (lines) result (title)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    character (len=300) :: title
    ! Calls: StringSplit
end function TableReadTitle
</PRE>
 Description:
 Read the title of the table. Title is optional. 
<PRE> Arguments:
     lines  collections of lines
 Result:
     Return title if exists</PRE>
<A NAME="function_tablereadid"><H3>TableReadId</H3></A>
<PRE>private function TableReadId (lines) result (id)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    character (len=300) :: id
    ! Calls: Catch, StringSplit
end function TableReadId
</PRE>
 Description:
 Read the Id of the table. Id is mandatory and must be unique. 
<PRE> Arguments:
     lines  collections of lines
 Result:
     Return Id</PRE>
<A NAME="subroutine_tablesgetfromfile"><H3>TablesGetFromFile</H3></A>
<PRE>private subroutine TablesGetFromFile (file, tables)
    character (len=*), INTENT (IN) :: file
    type (TableCollection), INTENT (OUT) :: tables
    ! Calls: Catch, CheckId, TableReadContent, TableReadHeader, TableReadUnit, TableStoreLines
end subroutine TablesGetFromFile
</PRE>
 Description:
 read a collection of tables from specified file. 
<PRE> Arguments:
     file     file in which table is contained
     tables      returned collection of tables</PRE>
<A NAME="subroutine_tablesgetfromunit"><H3>TablesGetFromUnit</H3></A>
<PRE>private subroutine TablesGetFromUnit (unit, tables)
    integer (kind=short), INTENT (IN) :: unit
    type (TableCollection), INTENT (OUT) :: tables
    ! Calls: Catch, CheckId, TableReadContent, TableReadHeader, TableReadUnit, TableStoreLines
end subroutine TablesGetFromUnit
</PRE>
 Description:
 read a collection of tables from specified unit. File is already open.
<PRE> Arguments:
     unit        unit of file in which table is contained
     tables      returned collection of tables</PRE>
<A NAME="subroutine_tablegetfromfile"><H3>TableGetFromFile</H3></A>
<PRE>private subroutine TableGetFromFile (file, tab, id)
    character (len=*), INTENT (IN) :: file
    type (Table), INTENT (OUT) :: tab
    character (len=*), optional, INTENT (IN) :: id
    ! Calls: Catch, TableReadContent, TableReadHeader, TableReadUnit, TableStoreLines
end subroutine TableGetFromFile
</PRE>
 Description:
 read a table from specified file. File is not yet open.
 If id is not specified, in a file containing multiple tables,
 the first table is read
<PRE> Arguments:
     file     file in which table is contained
     tab      returned table
     id       optional, id of table to read</PRE>
<A NAME="subroutine_tablegetfromunit"><H3>TableGetFromUnit</H3></A>
<PRE>private subroutine TableGetFromUnit (unit, tab, id)
    integer (kind=short), INTENT(IN) :: unit
    type (Table), INTENT (OUT) :: tab
    character (len=*), optional, INTENT (IN) :: id
    ! Calls: Catch, TableReadContent, TableReadHeader, TableReadUnit, TableStoreLines
end subroutine TableGetFromUnit
</PRE>
 Description:
 read a table from specified file unit. File is already open.
<PRE> Arguments:
     unit     file in which table is contained
     tab      returned table
     id       optional, id of table to read</PRE>
<A NAME="subroutine_tablereadcontent"><H3>TableReadContent</H3></A>
<PRE>private subroutine TableReadContent (lines, tab)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    type (Table), INTENT (OUT) :: tab
    ! Calls: StringSplit
end subroutine TableReadContent
</PRE>
 Description:
 read the content of the table. 
<PRE> Arguments:
     lines     collection of strings that contain table information
     tab       table to update</PRE>
<A NAME="subroutine_tablereadunit"><H3>TableReadUnit</H3></A>
<PRE>private subroutine TableReadUnit (lines, tab)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    type (Table), INTENT (OUT) :: tab
    ! Calls: StringSplit
end subroutine TableReadUnit
</PRE>
 Description:
 read unit of the columns of the table. 
<PRE> Arguments:
     lines     collection of strings that contain table information
     tab       table to update</PRE>
<A NAME="subroutine_tablereadheader"><H3>TableReadHeader</H3></A>
<PRE>private subroutine TableReadHeader (lines, tab)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    type (Table), INTENT (OUT) :: tab
    ! Calls: StringSplit
end subroutine TableReadHeader
</PRE>
 Description:
 read header of the columns of the table. 
<PRE> Arguments:
     lines     collection of strings that contain table information
     tab       table to update</PRE>
<A NAME="function_tablecountcols"><H3>TableCountCols</H3></A>
<PRE>private function TableCountCols (lines) result (cols)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    integer (kind=short) :: cols
    ! Calls: Catch, StringSplit
end function TableCountCols
</PRE>
 Description:
 Count the number of columns in a table stored in a collection of lines.
<PRE> Method:
 count the number of tokens included in parentheses []. 
 Arguments:
     lines     collections of lines
 Result:
     Return number of columns</PRE>
<A NAME="function_tablecountrows"><H3>TableCountRows</H3></A>
<PRE>private function TableCountRows (lines) result (rows)
    character (len=LINELENGTH), INTENT (IN), POINTER, dimension  (:) :: lines
    integer (kind=short) :: rows
    ! Calls: StringSplit
end function TableCountRows
</PRE>
 Description:
 Count the number of rowss in a table stored in a collection of lines.
<PRE> Method:
 count the number of non blank lines that have not a keyword. 
 Arguments:
     lines     collections of lines
 Result:
     Return number of rows</PRE>
<A NAME="subroutine_checkid"><H3>CheckId</H3></A>
<PRE>private subroutine CheckId (tables, pos)
    type (TableCollection), INTENT(IN) :: tables
    integer (kind=long), INTENT(IN) :: pos
    ! Calls: Catch
end subroutine CheckId
</PRE>
 Description:
 Check that table Id is not duplicated. Table id must be unique. 
<PRE> Arguments:
     tables     collections of tables
     pos      position of the last Id entry</PRE>
<A NAME="subroutine_tablestorelines"><H3>TableStoreLines</H3></A>
<PRE>private subroutine TableStoreLines (unit, lines)
    integer (kind=short), INTENT (IN) :: unit
    character (len=LINELENGTH), INTENT (OUT), POINTER, dimension  (:) :: lines
end subroutine TableStoreLines
</PRE>
 Description:
 read the lines of a table which are stored in an array of strings.
 Non significative lines (i.e. comments or blank lines) are ignored.
 Subroutine supposes that the cursor is sync to the first line after 
 the keyword 'Table Start'. hence it is must benn called after
 a call to tableFileSync. 
<PRE> Arguments:
     unit     file in which table is contained
     lines    returned collection of linestable</PRE>
<A NAME="function_tablegetnumberrows"><H3>TableGetNumberRows</H3></A>
<PRE>private function TableGetNumberRows (tab) result (rows)
    type (table), INTENT (IN) :: tab
    integer :: rows
end function TableGetNumberRows
</PRE>
 Description:
   return the number of rows in a table
<A NAME="function_tablesgetnumberrows"><H3>TablesGetNumberRows</H3></A>
<PRE>public function TablesGetNumberRows (tables, id) result (rows)
    type (TableCollection), INTENT (IN) :: tables
    character (len=*), INTENT (IN) :: id
    integer :: rows
end function TablesGetNumberRows
</PRE>
 Description:
  return the number of rows of a table in a table collection
</HTML>
