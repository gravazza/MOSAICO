<HTML>
<HEAD>
   <TITLE> module Morphology (generated by f90doc) </TITLE>
</HEAD>
<H1> Module Morphology </H1>
<PRE>module Morphology

        ! Uses
    use <A HREF="datatypesizes.html">DataTypeSizes</A>, ONLY: short, long, float
    use <A HREF="gridlib.html">GridLib</A>, ONLY: grid_integer, grid_real, NewGrid, ESRI_ASCII, ESRI_BINARY, NET_CDF
    use <A HREF="gridoperations.html">GridOperations</A>, ONLY: IsOutOfGrid, GetIJ, CellArea, GetXY
    use <A HREF="geolib.html">GeoLib</A>, ONLY: Coordinate, point1, point2, Distance
    use <A HREF="loglib.html">LogLib</A>, ONLY: Catch

        ! Variables
    integer, private, PARAMETER :: <A HREF="morphology.html#var_nw">NW</A> = 32
    integer, private, PARAMETER :: <A HREF="morphology.html#var_n">N</A> = 64
    integer, private, PARAMETER :: <A HREF="morphology.html#var_ne">NE</A> = 128
    integer, private, PARAMETER :: <A HREF="morphology.html#var_w">W</A> = 16
    integer, private, PARAMETER :: <A HREF="morphology.html#var_e">E</A> = 1
    integer, private, PARAMETER :: <A HREF="morphology.html#var_sw">SW</A> = 8
    integer, private, PARAMETER :: <A HREF="morphology.html#var_s">S</A> = 4
    integer, private, PARAMETER :: <A HREF="morphology.html#var_se">SE</A> = 2

        ! Subroutines and functions
    public subroutine <A HREF="morphology.html#subroutine_hortonorders">HortonOrders</A> (flowAccumulation, flowDirection, orders, basinOrder)
    private subroutine <A HREF="morphology.html#subroutine_confluenceisaround">ConfluenceIsAround</A> (row, col, i, j, flowDir, confluence, orders, Norder)
    public logical function <A HREF="morphology.html#function_checkoutlet">CheckOutlet</A> (iDown, jDown, flowDirection)
    public subroutine <A HREF="morphology.html#subroutine_downstreamcell">DownstreamCell</A> (iin, jin, dir, is, js, dx, grid)
    public subroutine <A HREF="morphology.html#subroutine_deriveslope">DeriveSlope</A> (dem, slope, flowDirection)
    public subroutine <A HREF="morphology.html#subroutine_flowaccumulation">FlowAccumulation</A> (fdir, facc)
    private recursive subroutine <A HREF="morphology.html#subroutine_basinarea">BasinArea</A> (r, c, fdir, area)
    public function <A HREF="morphology.html#function_cellisspring">CellIsSpring</A> (row, col, flowDir) result (spring)
    public subroutine <A HREF="morphology.html#subroutine_basindelineate">BasinDelineate</A> (fdir, x, y, mask)
    private recursive subroutine <A HREF="morphology.html#subroutine_basinmask">BasinMask</A> (basin, fdir, r, c)

end module Morphology
</PRE>
 This file is part of 
<P>
 MOSAICO -- MOdular library for raSter bAsed hydrologIcal appliCatiOn.
<P>
   Copyright (C) 2011 Giovanni Ravazzani
<P>
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
<P>
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
<P>
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 Module Description: 
   library to deal with river and basin morphology
<P>
<STRONG>Author:</STRONG> <a href="mailto:giovanni.ravazzani@polimi.it">Giovanni Ravazzani</a>
<P>
<STRONG>Version:</STRONG> 0.2 - 23th October 2010

<HR><H2> Description of Variables </H2>
<A NAME="var_nw"><H3>NW</H3></A>
<PRE>integer, private, PARAMETER :: NW = 32
</PRE>
<A NAME="var_n"><H3>N</H3></A>
<PRE>integer, private, PARAMETER :: N = 64
</PRE>
<A NAME="var_ne"><H3>NE</H3></A>
<PRE>integer, private, PARAMETER :: NE = 128
</PRE>
<A NAME="var_w"><H3>W</H3></A>
<PRE>integer, private, PARAMETER :: W = 16
</PRE>
<A NAME="var_e"><H3>E</H3></A>
<PRE>integer, private, PARAMETER :: E = 1
</PRE>
<A NAME="var_sw"><H3>SW</H3></A>
<PRE>integer, private, PARAMETER :: SW = 8
</PRE>
<A NAME="var_s"><H3>S</H3></A>
<PRE>integer, private, PARAMETER :: S = 4
</PRE>
<A NAME="var_se"><H3>SE</H3></A>
<PRE>integer, private, PARAMETER :: SE = 2
</PRE>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_hortonorders"><H3>HortonOrders</H3></A>
<PRE>public subroutine HortonOrders (flowAccumulation, flowDirection, orders, basinOrder)
    type (grid_real), INTENT (IN) :: flowAccumulation
    type (grid_integer), INTENT (IN) :: flowDirection
    type (grid_integer), INTENT (INOUT) :: orders
    integer, optional, INTENT (OUT) :: basinOrder
</PRE>
<DL><DD><DL><DD>
the maximum order of the basin
</DL></DL>
<PRE>    ! Calls: Catch, ConfluenceIsAround, DownstreamCell
end subroutine HortonOrders
</PRE>
 Description:
   returns a grid_integer containing Horton orders. Horton orders are 
   computed on the entire space-filled basin.
<A NAME="subroutine_confluenceisaround"><H3>ConfluenceIsAround</H3></A>
<PRE>private subroutine ConfluenceIsAround (row, col, i, j, flowDir, confluence, orders, Norder)
    integer, INTENT(IN) :: row
    integer, INTENT(IN) :: col
    integer, INTENT(IN) :: i
    integer, INTENT(IN) :: j
    type (grid_integer), INTENT(IN) :: flowDir
    logical, INTENT(OUT) :: confluence
    type (grid_integer), INTENT(IN) :: orders
    integer, INTENT(IN) :: Norder
end subroutine ConfluenceIsAround
</PRE>
 Description:
   Scan the eigth cells surrounding the center cell (row,col) (neglecting 
   the upstream cell (i,j) ) to find if a confluence is present.
   The confluence cell must be of the same order or not yet defined.
<A NAME="function_checkoutlet"><H3>CheckOutlet</H3></A>
<PRE>public logical function CheckOutlet (iDown, jDown, flowDirection)
    integer, INTENT(in) :: iDown
    integer, INTENT(in) :: jDown
    type (grid_integer), INTENT(in) :: flowDirection
end function CheckOutlet
</PRE>
 Description:
   if the downstream cell is a nodata or out of grid space, the current cell
   is the basin outlet
<A NAME="subroutine_downstreamcell"><H3>DownstreamCell</H3></A>
<PRE>public subroutine DownstreamCell (iin, jin, dir, is, js, dx, grid)
    integer (kind=short), INTENT (IN) :: iin
</PRE>
<DL><DD><DL><DD>
current cell
</DL></DL>
<PRE>    integer (kind=short), INTENT (IN) :: jin
</PRE>
<DL><DD><DL><DD>
current cell
</DL></DL>
<PRE>    integer (kind=long), INTENT (IN) :: dir
</PRE>
<DL><DD><DL><DD>
flow direction 
</DL></DL>
<PRE>    integer (kind=short), INTENT (OUT) :: is
</PRE>
<DL><DD><DL><DD>
downstream cell
</DL></DL>
<PRE>    integer (kind=short), INTENT (OUT) :: js
</PRE>
<DL><DD><DL><DD>
downstream cell
</DL></DL>
<PRE>    real (kind=float), optional, INTENT (OUT) :: dx
</PRE>
<DL><DD><DL><DD>
flow path length [m]
</DL></DL>
<PRE>    type (grid_integer), optional, INTENT (IN) :: grid
</PRE>
<DL><DD><DL><DD>
used to define coordinate reference system
</DL></DL>
<PRE>    ! Calls: Catch, GetXY
end subroutine DownstreamCell
</PRE>
 Description:
   returns the position (is,js) of the downstream cell and, optionally,
   the flow path length, considering cardinal and diagonal direction
<A NAME="subroutine_deriveslope"><H3>DeriveSlope</H3></A>
<PRE>public subroutine DeriveSlope (dem, slope, flowDirection)
    type (grid_real), INTENT(in) :: dem
    type (grid_real), INTENT (out) :: slope
    type (grid_integer), optional, INTENT(in) :: flowDirection
    ! Calls: DownstreamCell, NewGrid
end subroutine DeriveSlope
</PRE>
 Description:
   compute local slope in radians. If flowDirection is not supplied, slope 
   is calculated along greater slope direction, otherwise, slope is 
   calculated using elevation of downstream cell.
<A NAME="subroutine_flowaccumulation"><H3>FlowAccumulation</H3></A>
<PRE>public subroutine FlowAccumulation (fdir, facc)
    type (grid_integer), INTENT(in) :: fdir
    type (grid_real), INTENT (out) :: facc
    ! Calls: BasinArea, NewGrid
end subroutine FlowAccumulation
</PRE>
 Description:
   compute map of flow accumulation [m2]
   Input grid: flow direction
<A NAME="subroutine_basinarea"><H3>BasinArea</H3></A>
<PRE>private recursive subroutine BasinArea (r, c, fdir, area)
    integer, INTENt(in) :: r
    integer, INTENt(in) :: c
    type (grid_integer), INTENT(IN) :: fdir
    real (kind=float), INTENT(inout) :: area
    ! Calls: BasinArea
end subroutine BasinArea
</PRE>
 Description:
   compute basin area [m2]
<A NAME="function_cellisspring"><H3>CellIsSpring</H3></A>
<PRE>public function CellIsSpring (row, col, flowDir) result (spring)
    integer, INTENT(in) :: row
    integer, INTENT(in) :: col
    type (grid_integer), INTENT(in) :: flowDir
    logical :: spring
end function CellIsSpring
</PRE>
 Description:
   find the cells that are springs, defined as those cells that have not
   any other cells upstream
<A NAME="subroutine_basindelineate"><H3>BasinDelineate</H3></A>
<PRE>public subroutine BasinDelineate (fdir, x, y, mask)
    type (grid_integer), INTENT(in) :: fdir
    real (kind=float), INTENT(in) :: x
</PRE>
<DL><DD><DL><DD>
coordinate of outlet
</DL></DL>
<PRE>    real (kind=float), INTENT(in) :: y
</PRE>
<DL><DD><DL><DD>
coordinate of outlet
</DL></DL>
<PRE>    type (grid_integer), INTENT(inout) :: mask
    ! Calls: BasinMask, GetIJ
end subroutine BasinDelineate
</PRE>
 Description:
   compute mask of river basin given map of flow direction and the coordinate
   of the outlet point
<A NAME="subroutine_basinmask"><H3>BasinMask</H3></A>
<PRE>private recursive subroutine BasinMask (basin, fdir, r, c)
    type (grid_integer), INTENT(INOUT) :: basin
    type (grid_integer), INTENT(IN) :: fdir
    integer, INTENt(in) :: r
    integer, INTENt(in) :: c
    ! Calls: BasinMask
end subroutine BasinMask
</PRE>
 Description:
   search for cells included in the river basin
</HTML>
